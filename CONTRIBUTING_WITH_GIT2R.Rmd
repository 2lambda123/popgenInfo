---
title: "Contributing with git2r"
author: "Zhian N. Kamvar"
date: "December 16, 2015"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Introduction

## Background Motivation

The **popgenInfo** project was designed to be an educational tool that can move
at the same pace as method development by allowing people skilled in population
genetics analysis to submit workflows that demonstrate the strengths of any
given analysis in R. We use [git](https://git-scm.com/) and
[GitHub](https://github.com) to accept contributions via pull requests using
[GitHub flow](https://guides.github.com/introduction/flow/).

> **What is git?**
> 
> Git is a *version control* program. It allows you to keep track of all changes
that happen when you are writing, analyzing data, or coding. You can think of it
as a sort of electronic lab notebook. Just like you would record any weights or
measures carefully in your bench lab notebook, so should you record any analyses
you do on the computer. With git, you "add" and "commit" changes that you make.
These are analogous to writing down the values of your measurements and noting 
how you took them. 

The basic steps of the process are:

1. **Fork** the [popgenInfo repository](https://github.com/NESCent/popgenInfo)\*
2. **Clone** your fork to your local machine.\*
6. Checkout your master branch, **fetch** the changes from NESCent and **merge**
   them into your fork.
3. Create a new **branch** and then **add** and **commit** new changes or content.
4. **Push** your changes to your fork.
5. Open a **pull request** from your fork to NESCent.

\* These should only be done once.

This particular tutorial will show you the basics of contributing to the
popgenInfo website using the R package
[*git2r*](https://cran.r-project.org/package=git2r), which was developed by the
[rOpenSci project](https://ropensci.org/). This package allows for a nearly
seamless and uniform interface for all contributors regardless of operating
system.

## Requirements

We assume that you have already done a few things:

1. Signed up for a [GitHub account](https://github.com)
2. Install [R](https://cran.r-project.org)
3. Install [Rstudio](https://rstudio.com/desktop/download)

If you have also installed [git](https://git-scm.com/), you can set up Rstudio
to work with git to help you commit changes, pull, and push. For the purposes of
this tutorial, these things are not necessary.

# Step 1: Forking the repository.

Go to 
[https://github.com/NESCent/popgenInfo](https://github.com/NESCent/popgenInfo) 
and [click on the "Fork" 
button](https://help.github.com/articles/fork-a-repo/#fork-an-example-repository).
This will create a copy of the NESCent popgenInfo repository to your account.
After you've forked the repository, you never have to fork it again!

# Step 2: Clone your fork to your computer

Just like forking, you only have to clone your fork to your computer once. It
will live there until you decide to remove it.

Now that you have your repository forked to your account, you will need to 
**clone** it to your computer. For this, we will need two things:

1. a place you want to store this repostiory (eg. a folder called `forks` in your `Documents`)
2. git2r

```{r, tmpdir_setup, echo = FALSE}
fork_dir <- tempdir()
```

## Create your forks folder

First, we need to make sure that we are working in the folder where we want to
set up our fork. In this tutorial, we will use `setwd()` to do this via the R
console, but it is possible to do this via Rstudio.

If you are using Windows:

```{r, eval = FALSE}
fork_dir <- "~/forks"
```

If you are using OSX:

```{r, eval = FALSE}
fork_dir <- "~/Documents/forks"
```

Now, we create the directory and then move there:

```{r, eval = FALSE}
dir.create(fork_dir)
```

We can use the function `list.files()` to see what's inside the directory:

```{r showdir, eval = FALSE}
list.files()
```

```{r showshadow, echo = FALSE}
list.files(fork_dir)
```

Currently, there's nothing here. We will use the `clone()` function from *git2r*
to make a copy of our repository. If you type `help("clone", "git2r")` in your
R console, you can see documentation about the function. We need two things
from this function:

1. The URL of the git repository
2. The path to our folder where we want to store it

The URL for the git repository is simply just the URL for your fork with `.git` 
at the end of it. For mine, it's `https://github.com/zkamvar/popgenInfo.git`. To
keep things simple, we will name the folder we want to put the repository in
"popgenInfo".

```{r clone, eval = FALSE}
library("git2r")
clone(url = "https://github.com/zkamvar/popgenInfo.git",
      local_path = "popgenInfo")
```

```{r shadow_clone, echo = FALSE}
library("git2r")
clone(url = "https://github.com/zkamvar/popgenInfo.git",
      local_path = paste0(fork_dir, "/popgenInfo"))
```


Now when we look at our directory, we can see that we have one folder called 
"popgenInfo":

```{r show_clone, eval = FALSE}
list.files()
```

```{r show_shadow, echo = FALSE}
list.files(fork_dir)
```


We can move into the folder with `setwd()` and look at all the files in there.

```{r go_clone, eval = FALSE}
setwd("popgenInfo")
list.files()
```

```{r go_shadow, echo = FALSE}
list.files(paste0(fork_dir, "/popgenInfo"))
```

Now we have successfully cloned our repository into our computer using *git2r*. 
Next, we will set up our credentials and keep our master branch up to date.

## Setting up your clone

To access the repository, all you have to do is open it by double-clicking on
the "popgenInfo.Rproj" file. This will open Rstudio to this folder and set it as
the working directory. After that, in your R console, type:

```{r repository_show, eval = FALSE}
library("git2r") # in case you're starting from here
repo <- repository()
repo
```

```{r repository_shadow, echo = FALSE}
library("git2r") # in case you're starting from here
repo <- repository(paste0(fork_dir, "/popgenInfo"))
repo
```

This tells R that you have a repository in this folder and that you are
referring to it as `repo`. The output of `repo` is a summary of your repository:

 - **Local** This is the branch (master) and the path where the copy of your repository is.
 - **Remote** This shows you the branch and the url of the remote repository
 - **Head** This is a summary of the last *commit* containing the date and a description.

In order to be able to synch your clone with your fork, GitHub needs to know 
that you are really who you say you are. This means that you need to associate
your name, email, and a secret token with this repository. The first two items
are easily done within R. You can use the function `config()` to set and confirm
your name and email:

```{r, config}
config(repo, 
       user.name = "Zhian Kamvar",
       user.email = "kamvarz@science.oregonstate.edu")
config(repo)
```

Next, we need to set our secret token. Known as a [**Personal Access Token
(PAT)**](https://help.github.com/articles/creating-an-access-token-for-command-line-use/),
this is a 40 character cryptographic token that is like a long and complicated
password. They both allow access to your GitHub repository, but the difference
between a PAT and a password is that a PAT can be stored as text on your
computer (which you should NEVER do with passwords) because it is easy to
generate and (most importantly) easy to remove. We can create a PAT from GitHub
and then we will store this in a file called `.Renviron` that is read every time
you restart your R session, allowing you to have this token whenever you need to
push changes to your fork on GitHub. 

[The instructions to generate your PAT are
here](https://help.github.com/articles/creating-an-access-token-for-command-line-use/).
Once you have generated and copied your PAT, copy and paste it like this:

```{r github_pat}
my_pat <- "97cc6bf86c31a42fca2de32884cd1f1c4b1102ba" # replace this token with yours
```

Now, you can create a file called `.Renviron` inside of the repository. This
will not be tracked by git, and will only exist on your computer:

```{r renviron, eval = FALSE}
cat(paste0("GITHUB_PAT=\"", my_pat, "\""), file = ".Renviron")
```

```{r renviron_shadow, echo = FALSE}
cat(paste0("GITHUB_PAT=\"", my_pat, "\""), file = paste0(fork_dir, "/popgenInfo/.Renviron"))
```

The next time you open R from `popgenInfo.Rproj`, this token will be available
for GitHub to ensure that you are who you say you are. It is important to note
that, if you change or delete that PAT, you must replace it here.

In the next step, we will ensure that our fork is up to date with NESCent. In 
order to do that, we need to tell our local copy that it can take updates from 
NESCent. We do this by adding NESCent as a **remote** using the function 
`remote_add()` and checking to make sure it worked with the function
`remotes()`.

```{r remote_add}
remote_add(repo, 
           name = "NESCent", 
           url = "https://github.com/NESCent/popgenInfo.git")

# Check our remotes
remotes(repo)
```

With all of this information set, we can begin working on our repository.

# Step 3: Keeping your fork up to date

The first thing we need to do is make sure that our master branch is up to date.
Since other people are also contributing to this project, it is possible for
changes to be made even within seconds of you forking the repository. In this
section we will show you how you can keep your master branch up to date in your
local repository and your fork on github. 

Let's assume that you've just opened a fresh Rstudio session with the
`popgenInfo.Rproj` file. First, let's load *git2r* and access our repository.

```{r git2r_show, eval = FALSE}
library("git2r")
repo <- repository()
```

Now that we have our repository loaded, we should make sure that we are on the
**master branch**. We can do this using the `checkout()` function from *git2r*.

```{r checkout_master}
checkout(repo, "master")
repo
```

Now, whether or not we suspect changes from NESCent, it's always good form to 
update your local repository before creating any new branches. We can do it this
by first **fetch**ing the NESCent master branch and then **merging** it into our
master branch. We will use the *git2r* functions `fetch()` and `merge()` to
accomplish this.

```{r update_master}
fetch(repo, name = "NESCent")
merge(repo, "NESCent/master")
repo
```

Since we will never work directly on the master branch, there should be no 
conflicts from the NESCent branch and we now know that our branch is up to date.
Assuming everything worked, we can push this to our fork on GitHub. We will use 
*git2r*'s `push()` function to do this. We also need to supply our PAT in order
for this to work. To do so, we will use the *git2r* function `cred_token()`:

```{r push_repo, eval = FALSE}
cred <- cred_token()
push(repo, credentials = cred)
```

Now, when you check your fork, it should be updated with the most recent
changes. From here, we can checkout a new branch and then proceed with adding 
our changes or new workflow.

# Step 4: Creating a New Branch

When you add contributions, the best practice is to create a new branch off of
the master. A **branch** is a term that indicates a sort of sandbox for a 
repository that can become permenant. By default, git repositories all have a 
"master" branch. When you want to experiment with something else, add new
content, or simply just fix a typo, but you don't want to disturb the original
copy, you create a new branch. In this step, we will create a branch, push it to
our fork, and track it.

## SETUP

Most importantly we need to make sure that we are on the master branch and it is
up to date. To double plus make sure that you are on the master branch, check it
out:

```{r chchcheckitout}
checkout(repo, "master")
repo
```

For reasons that will reveal themselves later, please run these function
definitions:

```{r fun}
my_branch <- function(x) paste0("refs/heads/", x)
my_origin <- function(x) paste0("origin/", x)
```

And, of course, don't forget your credentials:

```{r cred}
cred <- cred_token()
```


## Creation

Assuming you've updated your master branch as shown above, we can create a 
branch from the master using the function `checkout()`. Let's assume that we 
want to create a vignette for analyzing spatial statistics. I'm going to lay out
a few steps here all at once because these are the steps you want to take when
you create a brand new branch and make sure it exists on your computer and on
your fork:

1. save the branch name as a variable
2. checkout the branch
3. push the branch to the fork
4. set your local repository to track the fork

In code, that would look like this if you wanted to create a new branch to
include a vignette on spatial statistics called "2015-12-16-spatial-stats":

```{r checkout_branch_flow, eval = FALSE}
BRANCH <- "2015-12-16-spatial-stats"                                         # 1
checkout(repo, BRANCH, create = TRUE)                                        # 2
push(repo, name = "origin", refspec = my_branch(BRANCH), credentials = cred) # 3
branch_set_upstream(head(repo), my_origin(BRANCH))                           # 4
```

To examine these one by one. First, you create a variable that will hold the
name of the branch you want to create. We are using this convention to allow us
to use this name multiple times. After that, we create that branch from our
master branch. We can take a look at what our branch looks like at that point.

```{r checkout_branch, eval = FALSE}
BRANCH <- "2015-12-16-spatial-stats"  # 1
checkout(repo, BRANCH, create = TRUE) # 2
repo
```
```{r checkout_branch_shadow, echo = FALSE}
BRANCH <- "2015-12-16-spatial-stats"
# Thu Dec 17 09:57:31 2015 ------------------------------
# I have this branch created on my fork, but if I check it out normally, it will
# automatically track the fork. Instead, I am creating this branch from the
# nescent head so that it appears seamless when the user does this.
branch_create(commits(repo)[[1]], BRANCH)
checkout(repo, BRANCH, create = TRUE)
repo
branch_set_upstream(head(repo), my_origin(BRANCH))
```

Notice here that you now only have two lines in the output, **Local** and
**Head**. This is because the branch doesn't exist on your GitHub fork. This is
where the next two steps come in. We will push that branch and then make sure
that our branch is tracking the copy on the fork.

```{r push_branch, eval = FALSE}
push(repo, name = "origin", refspec = my_branch(BRANCH), credentials = cred) # 3
branch_set_upstream(head(repo), my_origin(BRANCH))                           # 4
repo
```
```{r push_branch_shadow, echo = FALSE}
repo
```

We can now see from the output that we have a **Remote** set up. Once we have 
this, we can start making changes! If you are adding a new vignette, please copy
[`TEMPLATE.Rmd`](https://github.com/nescent/popgenInfo/tree/master/TEMPLATE.Rmd)
to the **use/** directory and give it a new name that is meaningful to your 
contribution (good practice is to name it the same as your branch). If you are
including any data, place it in the **data/** directory. Once you add these
files, you need to to **add** these files and then you should **commit**, which
we will show you how to do below.

# Step 5: Adding content, committing, and pushing

If you are using Rstudio, you can use it to integrate with git. This allows you 
to do things like commit, push, and pull. Hadley Wickham, cheif scientist at 
Rstudio has put up [this helpful tutorial on using git through 
Rstudio](http://r-pkgs.had.co.nz/git.html#git-status). If you aren't using
Rstudio, but you don't want to access the terminal (command line), this section
will show you basic git commands with *git2r* that will allow you to work on
your vignette and keep it up to date.

Recall that usng git is analogous to keeping a good, detailed lab notebook. When
you make any changes, you record those changes (`git add`) and then say *why*
you made the changes (`git commit`).

Let's say you've already copied the `TEMPLATE.Rmd` file to the **use/**
directory and renamed it to `2015-12-16-spatial-stats.Rmd` and added some data
called `spatial_data.csv`.


# Session Information

This shows us useful information for reproducibility. Of particular importance
are the versions of R and the packages used to create this workflow. It is
considered good practice to record this information with every analysis.

```{r, sessioninfo}
options(width = 100)
devtools::session_info()
```